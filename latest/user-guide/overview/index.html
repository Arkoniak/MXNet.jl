<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="no-js ie6"><![endif]-->
<!--[if IE 7 ]><html class="no-js ie7"><![endif]-->
<!--[if IE 8 ]><html class="no-js ie8"><![endif]-->
<!--[if IE 9 ]><html class="no-js ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    
      
        <title>Overview - MXNet.jl</title>
      
      
      
      
    
    <meta property="og:url" content="None">
    <meta property="og:title" content="MXNet.jl">
    <meta property="og:image" content="None/../../">
    <meta name="apple-mobile-web-app-title" content="MXNet.jl">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <link rel="icon" type="image/x-icon" href="../../assets/images/favicon-e565ddfa3b.ico">
    <style>
      @font-face {
      	font-family: 'Icon';
      	src: url('../../assets/fonts/icon.eot?52m981');
      	src: url('../../assets/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
      		   url('../../assets/fonts/icon.woff?52m981')
               format('woff'),
      		   url('../../assets/fonts/icon.ttf?52m981')
               format('truetype'),
      		   url('../../assets/fonts/icon.svg?52m981#icon')
               format('svg');
      	font-weight: normal;
      	font-style: normal;
      }
    </style>
    <link rel="stylesheet" href="../../assets/stylesheets/application-a422ff04cc.css">
    
      <link rel="stylesheet" href="../../assets/stylesheets/palettes-05ab2406df.css">
    
    
      
      
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu+Mono">
      <style>
        body, input {
          font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
        }
        pre, code {
          font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
        }
      </style>
    
    
      <link rel="stylesheet" href="../../assets/Documenter.css">
    
    <script src="../../assets/javascripts/modernizr-4ab42b99fd.js"></script>
    
  </head>
  
  
  
  <body class="palette-primary-indigo palette-accent-blue">
    
      
      
    
    <div class="backdrop">
      <div class="backdrop-paper"></div>
    </div>
    <input class="toggle" type="checkbox" id="toggle-drawer">
    <input class="toggle" type="checkbox" id="toggle-search">
    <label class="toggle-button overlay" for="toggle-drawer"></label>
    <header class="header">
      <nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
          <span class="path">
            
              
                User Guide <i class="icon icon-link"></i>
              
            
          </span>
        
        Overview
      </div>
    </div>
    
    
    <div class="button button-search" role="button" aria-label="Search">
      <label class="toggle-button icon icon-search" title="Search" for="toggle-search"></label>
    </div>
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
    </header>
    <main class="main">
      
      <div class="drawer">
        <nav aria-label="Navigation">
  
  <a href="https://github.com/dmlc/MXNet.jl" class="project">
    <div class="banner">
      
      <div class="name">
        <strong>
          MXNet.jl
          <span class="version">
            
          </span>
        </strong>
        
          <br>
          dmlc/MXNet.jl
        
      </div>
    </div>
  </a>
  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            
            <a href="https://github.com/dmlc/MXNet.jl/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/dmlc/MXNet.jl/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      
      <div class="toc">
        <ul>
          
            
  <li>
    <a class="" title="Home" href="../..">
      Home
    </a>
    
  </li>

          
            
  <li>
    <span class="section">Tutorial</span>
    <ul>
      
        
  <li>
    <a class="" title="Digit Recognition on MNIST" href="../../tutorial/mnist/">
      Digit Recognition on MNIST
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Generating Random Sentence with LSTM RNN" href="../../tutorial/char-lstm/">
      Generating Random Sentence with LSTM RNN
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">User Guide</span>
    <ul>
      
        
  <li>
    <a class="" title="Installation Guide" href="../install/">
      Installation Guide
    </a>
    
  </li>

      
        
  <li>
    <a class="current" title="Overview" href="./">
      Overview
    </a>
    
      
        
      
      
        <ul>
          
            <li class="anchor">
              <a title="MXNet.jl Namespace" href="#mxnetjl-namespace">
                MXNet.jl Namespace
              </a>
            </li>
          
            <li class="anchor">
              <a title="Low Level Interface" href="#low-level-interface">
                Low Level Interface
              </a>
            </li>
          
            <li class="anchor">
              <a title="Intermediate Level Interface" href="#intermediate-level-interface">
                Intermediate Level Interface
              </a>
            </li>
          
            <li class="anchor">
              <a title="High Level Interface" href="#high-level-interface">
                High Level Interface
              </a>
            </li>
          
        </ul>
      
    
  </li>

      
        
  <li>
    <a class="" title="FAQ" href="../faq/">
      FAQ
    </a>
    
  </li>

      
    </ul>
  </li>

          
            
  <li>
    <span class="section">API Documentation</span>
    <ul>
      
        
  <li>
    <a class="" title="Context" href="../../api/context/">
      Context
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Models" href="../../api/model/">
      Models
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Initializers" href="../../api/initializer/">
      Initializers
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Optimizers" href="../../api/optimizer/">
      Optimizers
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Callbacks in training" href="../../api/callback/">
      Callbacks in training
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Evaluation Metrics" href="../../api/metric/">
      Evaluation Metrics
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Data Providers" href="../../api/io/">
      Data Providers
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="NDArray API" href="../../api/ndarray/">
      NDArray API
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Symbolic API" href="../../api/symbolic-node/">
      Symbolic API
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Neural Networks Factory" href="../../api/nn-factory/">
      Neural Networks Factory
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Executor" href="../../api/executor/">
      Executor
    </a>
    
  </li>

      
        
  <li>
    <a class="" title="Network Visualization" href="../../api/visualize/">
      Network Visualization
    </a>
    
  </li>

      
    </ul>
  </li>

          
        </ul>
        
      </div>
    </div>
  </div>
</nav>
      </div>
      <article class="article">
        <div class="wrapper">
          
          <p><a id='Overview-1'></a></p>
<h1 id="overview">Overview</h1>
<p><a id='MXNet.jl-Namespace-1'></a></p>
<h2 id="mxnetjl-namespace">MXNet.jl Namespace</h2>
<p>Most the functions and types in MXNet.jl are organized in a flat namespace. Because many some functions are conflicting with existing names in the Julia Base module, we wrap them all in a <code>mx</code> module. The convention of accessing the MXNet.jl interface is the to use the <code>mx.</code> prefix explicitly:</p>
<pre><code class="julia">using MXNet

x = mx.zeros(2,3)              # MXNet NDArray
y = zeros(eltype(x), size(x))  # Julia Array
copy!(y, x)                    # Overloaded function in Julia Base
z = mx.ones(size(x), mx.gpu()) # MXNet NDArray on GPU
mx.copy!(z, y)                 # Same as copy!(z, y)
</code></pre>

<p>Note functions like <code>size</code>, <code>copy!</code> that is extensively overloaded for various types works out of the box. But functions like <code>zeros</code> and <code>ones</code> will be ambiguous, so we always use the <code>mx.</code> prefix. If you prefer, the <code>mx.</code> prefix can be used explicitly for all MXNet.jl functions, including <code>size</code> and <code>copy!</code> as shown in the last line.</p>
<p><a id='Low-Level-Interface-1'></a></p>
<h2 id="low-level-interface">Low Level Interface</h2>
<p><a id='NDArrays-1'></a></p>
<h3 id="ndarrays">NDArrays</h3>
<p>NDArray is the basic building blocks of the actual computations in MXNet. It is like a Julia <code>Array</code> object, with some important differences listed here:</p>
<ul>
<li>The actual data could live on different <code>Context</code> (e.g. GPUs). For   some contexts, iterating into the elements one by one is very slow,   thus indexing into NDArray is not supported in general. The easiest   way to inspect the contents of an NDArray is to use the <code>copy</code>   function to copy the contents as a Julia <code>Array</code>.</li>
<li>Operations on NDArray (including basic arithmetics and neural   network related operators) are executed in parallel with automatic   dependency tracking to ensure correctness.</li>
<li>There is no generics in NDArray, the <code>eltype</code> is always   <code>mx.MX_float</code>. Because for applications in machine learning, single   precision floating point numbers are typical a best choice balancing   between precision, speed and portability. Also since libmxnet is   designed to support multiple languages as front-ends, it is much   simpler to implement with a fixed data type.</li>
</ul>
<p>While most of the computation is hidden in libmxnet by operators corresponding to various neural network layers. Getting familiar with the NDArray API is useful for implementing <code>Optimizer</code> or customized operators in Julia directly.</p>
<p>The followings are common ways to create NDArray objects:</p>
<ul>
<li><code>mx.empty(shape[, context])</code>: create on uninitialized array of a   given shape on a specific device. For example,   $mx.empty(2,3)<code>,</code>mx.((2,3), mx.gpu(2))$.</li>
<li><code>mx.zeros(shape[, context])</code> and <code>mx.ones(shape[, context])</code>:   similar to the Julia's built-in <code>zeros</code> and <code>ones</code>.</li>
<li><code>mx.copy(jl_arr, context)</code>: copy the contents of a Julia <code>Array</code> to   a specific device.</li>
</ul>
<p>Most of the convenient functions like <code>size</code>, <code>length</code>, <code>ndims</code>, <code>eltype</code> on array objects should work out-of-the-box. Although indexing is not supported, it is possible to take <em>slices</em>:</p>
<pre><code class="julia">a = mx.ones(2,3)
b = mx.slice(a, 1:2)
b[:] = 2
println(copy(a))
# =&gt;
# Float32[2.0 2.0 1.0
#         2.0 2.0 1.0]
</code></pre>

<p>A slice is a sub-region sharing the same memory with the original NDArray object. A slice is always a contiguous piece of memory, so only slicing on the <em>last</em> dimension is supported. The example above also shows a way to set the contents of an NDArray.</p>
<pre><code class="julia">a = mx.empty(2,3)
a[:] = 0.5              # set all elements to a scalar
a[:] = rand(size(a))    # set contents with a Julia Array
copy!(a, rand(size(a))) # set value by copying a Julia Array
b = mx.empty(size(a))
b[:] = a                # copying and assignment between NDArrays
</code></pre>

<p>Note due to the intrinsic design of the Julia language, a normal assignment</p>
<pre><code class="julia">a = b
</code></pre>

<p>does <strong>not</strong> mean copying the contents of <code>b</code> to <code>a</code>. Instead, it just make the variable <code>a</code> pointing to a new object, which is <code>b</code>. Similarly, inplace arithmetics does not work as expected:</p>
<pre><code class="julia">a = mx.ones(2)
r = a           # keep a reference to a
b = mx.ones(2)
a += b          # translates to a = a + b
println(copy(a))
# =&gt; Float32[2.0f0,2.0f0]
println(copy(r))
# =&gt; Float32[1.0f0,1.0f0]
</code></pre>

<p>As we can see, <code>a</code> has expected value, but instead of inplace updating, a new NDArray is created and <code>a</code> is set to point to this new object. If we look at <code>r</code>, which still reference to the old <code>a</code>, its content has not changed. There is currently no way in Julia to overload the operators like <code>+=</code> to get customized behavior.</p>
<p>Instead, you will need to write <code>a[:] = a+b</code>, or if you want <em>real</em> inplace <code>+=</code> operation, MXNet.jl provides a simple macro <code>@mx.inplace</code>:</p>
<pre><code class="julia">@mx.inplace a += b
macroexpand(:(@mx.inplace a += b))
# =&gt; :(MXNet.mx.add_to!(a,b))
</code></pre>

<p>As we can see, it translate the <code>+=</code> operator to an explicit <code>add_to!</code> function call, which invokes into libmxnet to add the contents of <code>b</code> into <code>a</code> directly. For example, the following is the update rule in the SGD <code>Optimizer</code> (both <code>grad</code> and <code>weight</code> are NDArray objects):</p>
<pre><code class="julia">@inplace weight += -lr * (grad_scale * grad + self.weight_decay * weight)
</code></pre>

<p>Note there is no much magic in <code>mx.inplace</code>: it only does a shallow translation. In the SGD update rule example above, the computation like scaling the gradient by <code>grad_scale</code> and adding the weight decay all create temporary NDArray objects. To mitigate this issue, libmxnet has a customized memory allocator designed specifically to handle this kind of situations. The following snippet does a simple benchmark on allocating temp NDArray vs. pre-allocating:</p>
<pre><code class="julia">using Benchmark
using MXNet

N_REP = 1000
SHAPE = (128, 64)
CTX   = mx.cpu()
LR    = 0.1

function inplace_op()
  weight = mx.zeros(SHAPE, CTX)
  grad   = mx.ones(SHAPE, CTX)

  # pre-allocate temp objects
  grad_lr = mx.empty(SHAPE, CTX)

  for i = 1:N_REP
    copy!(grad_lr, grad)
    @mx.inplace grad_lr .*= LR
    @mx.inplace weight -= grad_lr
  end
  return weight
end

function normal_op()
  weight = mx.zeros(SHAPE, CTX)
  grad   = mx.ones(SHAPE, CTX)

  for i = 1:N_REP
    weight[:] -= LR * grad
  end
  return weight
end

# make sure the results are the same
@assert(maximum(abs(copy(normal_op() - inplace_op()))) &lt; 1e-6)

println(compare([inplace_op, normal_op], 100))
</code></pre>

<p>The comparison on my laptop shows that <code>normal_op</code> while allocating a lot of temp NDArray in the loop (the performance gets worse when increasing <code>N_REP</code>), is only about twice slower than the pre-allocated one.</p>
<p>Row    Function        Average      Relative    Replications   ––– –––––––- –––––– –––––- –––––––-   1      "inplace_op"   0.0074854    1.0         100   2      "normal_op"    0.0174202    2.32723     100</p>
<p>So it will usually not be a big problem unless you are at the bottleneck of the computation.</p>
<p><a id='Distributed-Key-value-Store-1'></a></p>
<h3 id="distributed-key-value-store">Distributed Key-value Store</h3>
<p>The type <code>KVStore</code> and related methods are used for data sharing across different devices or machines. It provides a simple and efficient integer - NDArray key-value storage system that each device can pull or push.</p>
<p>The following example shows how to create a local <code>KVStore</code>, initialize a value and then pull it back.</p>
<pre><code class="julia">kv    = mx.KVStore(:local)
shape = (2,3)
key   = 3

mx.init!(kv, key, mx.ones(shape)*2)
a = mx.empty(shape)
mx.pull!(kv, key, a) # pull value into a
println(copy(a))
# =&gt;
# Float32[2.0 2.0 2.0
#        2.0 2.0 2.0]
</code></pre>

<p><a id='Intermediate-Level-Interface-1'></a></p>
<h2 id="intermediate-level-interface">Intermediate Level Interface</h2>
<p><a id='Symbols-and-Composition-1'></a></p>
<h3 id="symbols-and-composition">Symbols and Composition</h3>
<p>The way we build deep learning models in MXNet.jl is to use the powerful symbolic composition system. It is like <a href="http://deeplearning.net/software/theano/">Theano</a>, except that we avoided long expression compiliation time by providing <em>larger</em> neural network related building blocks to guarantee computation performance. See also <a href="http://mxnet.readthedocs.org/en/latest/program_model.html">this note</a> for the design and trade-off of the MXNet symbolic composition system.</p>
<p>The basic type is <code>mx.Symbol</code>. The following is a trivial example of composing two symbols with the <code>+</code> operation.</p>
<pre><code class="julia">A = mx.Variable(:A)
B = mx.Variable(:B)
C = A + B
</code></pre>

<p>We get a new <em>symbol</em> by composing existing <em>symbols</em> by some <em>operations</em>. A hierarchical architecture of a deep neural network could be realized by recursive composition. For example, the following code snippet shows a simple 2-layer MLP construction, using a hidden layer of 128 units and a ReLU activation function.</p>
<pre><code class="julia">net = mx.Variable(:data)
net = mx.FullyConnected(data=net, name=:fc1, num_hidden=128)
net = mx.Activation(data=net, name=:relu1, act_type=:relu)
net = mx.FullyConnected(data=net, name=:fc2, num_hidden=64)
net = mx.Softmax(data=net, name=:out)
</code></pre>

<p>Each time we take the previous symbol, and compose with an operation. Unlike the simple <code>+</code> example above, the <em>operations</em> here are "bigger" ones, that correspond to common computation layers in deep neural networks.</p>
<p>Each of those operation takes one or more input symbols for composition, with optional hyper-parameters (e.g. <code>num_hidden</code>, <code>act_type</code>) to further customize the composition results.</p>
<p>When applying those operations, we can also specify a <code>name</code> for the result symbol. This is convenient if we want to refer to this symbol later on. If not supplied, a name will be automatically generated.</p>
<p>Each symbol takes some arguments. For example, in the <code>+</code> case above, to compute the value of <code>C</code>, we will need to know the values of the two inputs <code>A</code> and <code>B</code>. For neural networks, the arguments are primarily two categories: <em>inputs</em> and <em>parameters</em>. <em>inputs</em> are data and labels for the networks, while <em>parameters</em> are typically trainable <em>weights</em>, <em>bias</em>, <em>filters</em>.</p>
<p>When composing symbols, their arguments accumulates. We can list all the arguments by</p>
<pre><code class="julia">julia&gt; mx.list_arguments(net)
6-element Array{Symbol,1}:
 :data         # Input data, name from the first data variable
 :fc1_weight   # Weights of the fully connected layer named :fc1
 :fc1_bias     # Bias of the layer :fc1
 :fc2_weight   # Weights of the layer :fc2
 :fc2_bias     # Bias of the layer :fc2
 :out_label    # Input label, required by the softmax layer named :out
</code></pre>

<p>Note the names of the arguments are generated according to the provided name for each layer. We can also specify those names explicitly:</p>
<pre><code class="julia">net = mx.Variable(:data)
w   = mx.Variable(:myweight)
net = mx.FullyConnected(data=data, weight=w, name=:fc1, num_hidden=128)
mx.list_arguments(net)
# =&gt;
# 3-element Array{Symbol,1}:
#  :data
#  :myweight
#  :fc1_bias
</code></pre>

<p>The simple fact is that a <code>Variable</code> is just a placeholder <code>mx.Symbol</code>. In composition, we can use arbitrary symbols for arguments. For example:</p>
<pre><code class="julia">net  = mx.Variable(:data)
net  = mx.FullyConnected(data=net, name=:fc1, num_hidden=128)
net2 = mx.Variable(:data2)
net2 = mx.FullyConnected(data=net2, name=:net2, num_hidden=128)
mx.list_arguments(net2)
# =&gt;
# 3-element Array{Symbol,1}:
#  :data2
#  :net2_weight
#  :net2_bias
composed_net = net2(data2=net, name=:composed)
mx.list_arguments(composed_net)
# =&gt;
# 5-element Array{Symbol,1}:
#  :data
#  :fc1_weight
#  :fc1_bias
#  :net2_weight
#  :net2_bias
</code></pre>

<p>Note we use a composed symbol, <code>net</code> as the argument <code>data2</code> for <code>net2</code> to get a new symbol, which we named <code>:composed</code>. It also shows that a symbol itself is a call-able object, which can be invoked to fill in missing arguments and get more complicated symbol compositions.</p>
<p><a id='Shape-Inference-1'></a></p>
<h3 id="shape-inference">Shape Inference</h3>
<p>Given enough information, the shapes of all arguments in a composed symbol could be inferred automatically. For example, given the input shape, and some hyper-parameters like <code>num_hidden</code>, the shapes for the weights and bias in a neural network could be inferred.</p>
<pre><code class="julia">net = mx.Variable(:data)
net = mx.FullyConnected(data=net, name=:fc1, num_hidden=10)
arg_shapes, out_shapes, aux_shapes = mx.infer_shape(net, data=(10, 64))
</code></pre>

<p>The returned shapes corresponds to arguments with the same order as returned by <code>mx.list_arguments</code>. The <code>out_shapes</code> are shapes for outputs, and <code>aux_shapes</code> can be safely ignored for now.</p>
<pre><code class="julia">for (n,s) in zip(mx.list_arguments(net), arg_shapes)
  println(&quot;$n =&gt; $s&quot;)
end
# =&gt;
# data =&gt; (10,64)
# fc1_weight =&gt; (10,10)
# fc1_bias =&gt; (10,)
for (n,s) in zip(mx.list_outputs(net), out_shapes)
  println(&quot;$n =&gt; $s&quot;)
end
# =&gt;
# fc1_output =&gt; (10,64)
</code></pre>

<p><a id='Binding-and-Executing-1'></a></p>
<h3 id="binding-and-executing">Binding and Executing</h3>
<p>In order to execute the computation graph specified a composed symbol, we will <em>bind</em> the free variables to concrete values, specified as <code>mx.NDArray</code>. This will create an <code>mx.Executor</code> on a given <code>mx.Context</code>. A context describes the computation devices (CPUs, GPUs, etc.) and an executor will carry out the computation (forward/backward) specified in the corresponding symbolic composition.</p>
<pre><code class="julia">A = mx.Variable(:A)
B = mx.Variable(:B)
C = A .* B
a = mx.ones(3) * 4
b = mx.ones(3) * 2
c_exec = mx.bind(C, context=mx.cpu(), args=Dict(:A =&gt; a, :B =&gt; b))

mx.forward(c_exec)
copy(c_exec.outputs[1])  # copy turns NDArray into Julia Array
# =&gt;
# 3-element Array{Float32,1}:
#  8.0
#  8.0
#  8.0
</code></pre>

<p>For neural networks, it is easier to use <code>simple_bind</code>. By providing the shape for input arguments, it will perform a shape inference for the rest of the arguments and create the NDArray automatically. In practice, the binding and executing steps are hidden under the <code>Model</code> interface.</p>
<p><strong>TODO</strong> Provide pointers to model tutorial and further details about binding and symbolic API.</p>
<p><a id='High-Level-Interface-1'></a></p>
<h2 id="high-level-interface">High Level Interface</h2>
<p>The high level interface include model training and prediction API, etc.</p>
          <aside class="copyright" role="note">
            
            Documentation built with
            <a href="http://www.mkdocs.org" target="_blank">MkDocs</a>
            using the
            <a href="http://squidfunk.github.io/mkdocs-material/" target="_blank">
              Material
            </a>
            theme.
          </aside>
          
            <footer class="footer">
              
  <nav class="pagination" aria-label="Footer">
    <div class="previous">
      
        <a href="../install/" title="Installation Guide">
          <span class="direction">
            Previous
          </span>
          <div class="page">
            <div class="button button-previous" role="button" aria-label="Previous">
              <i class="icon icon-back"></i>
            </div>
            <div class="stretch">
              <div class="title">
                Installation Guide
              </div>
            </div>
          </div>
        </a>
      
    </div>
    <div class="next">
      
        <a href="../faq/" title="FAQ">
          <span class="direction">
            Next
          </span>
          <div class="page">
            <div class="stretch">
              <div class="title">
                FAQ
              </div>
            </div>
            <div class="button button-next" role="button" aria-label="Next">
              <i class="icon icon-forward"></i>
            </div>
          </div>
        </a>
      
    </div>
  </nav>

            </footer>
          
        </div>
      </article>
      <div class="results" role="status" aria-live="polite">
        <div class="scrollable">
          <div class="wrapper">
            <div class="meta"></div>
            <div class="list"></div>
          </div>
        </div>
      </div>
    </main>
    <script>
      var base_url = '../..';
      var repo_id  = 'dmlc/MXNet.jl';
    </script>
    <script src="../../assets/javascripts/application-997097ee0c.js"></script>
    
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.jl?config=TeX-AMS-MML_HTMLorMML"></script>
    
      <script src="../../assets/mathjaxhelper.js"></script>
    
    
  </body>
</html>